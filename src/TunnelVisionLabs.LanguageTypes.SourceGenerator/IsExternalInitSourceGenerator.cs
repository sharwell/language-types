// Copyright (c) Tunnel Vision Laboratories, LLC. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace TunnelVisionLabs.LanguageTypes.SourceGenerator
{
    using Microsoft.CodeAnalysis;

    [Generator(LanguageNames.CSharp)]
    internal class IsExternalInitSourceGenerator : IIncrementalGenerator
    {
        private const string IsExternalInitSource = @"// <auto-generated/>

namespace System.Runtime.CompilerServices
{
    /// <summary>
    /// Reserved to be used by the compiler for tracking metadata.
    /// This class should not be used by developers in source code.
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    internal static class IsExternalInit
    {
    }
}
";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var referencedTypesData = context.CompilationProvider.Select(
                (compilation, cancellationToken) =>
                {
                    var hasIsExternalInit = IsCompilerTypeAvailable(compilation, "System.Runtime.CompilerServices.IsExternalInit");

                    return new ReferencedTypesData(
                        hasIsExternalInit: hasIsExternalInit);
                });

            context.RegisterSourceOutput(
                referencedTypesData,
                (context, referencedTypesData) =>
                {
                    var forwarders = new List<string>();

                    if (!referencedTypesData.HasIsExternalInit)
                    {
                        context.AddSource("IsExternalInit.g.cs", IsExternalInitSource);
                    }
                    else
                    {
                        forwarders.Add("IsExternalInit");
                    }

                    if (forwarders.Count > 0)
                    {
                        var compilerForwarders = $@"// <auto-generated/>

using System.Runtime.CompilerServices;

{string.Join("\r\n", forwarders.Select(forwarder => $"[assembly: TypeForwardedTo(typeof({forwarder}))]"))}
";

                        context.AddSource("CompilerForwarders.g.cs", compilerForwarders);
                    }
                });
        }

        private static bool IsCompilerTypeAvailable(Compilation compilation, string fullyQualifiedMetadataName)
            => compilation.GetBestTypeByMetadataName(fullyQualifiedMetadataName, requiresAccess: true) is not null;

        private sealed class ReferencedTypesData
        {
            public ReferencedTypesData(bool hasIsExternalInit)
            {
                HasIsExternalInit = hasIsExternalInit;
            }

            public bool HasIsExternalInit { get; }
        }
    }
}
